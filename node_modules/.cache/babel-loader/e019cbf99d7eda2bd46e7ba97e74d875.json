{"ast":null,"code":"'use strict';\n\nconst {\n  bases\n} = require('multiformats/basics');\n/**\n * @typedef {import('multiformats/bases/interface').MultibaseCodec<any>} MultibaseCodec\n */\n\n/**\n * @param {string} name\n * @param {string} prefix\n * @param {(buf: Uint8Array) => string} encode\n * @param {(str: string) => Uint8Array} decode\n * @returns {MultibaseCodec}\n */\n\n\nfunction createCodec(name, prefix, encode, decode) {\n  return {\n    name,\n    prefix,\n    encoder: {\n      name,\n      prefix,\n      encode\n    },\n    decoder: {\n      decode\n    }\n  };\n}\n\nconst string = createCodec('utf8', 'u', buf => {\n  const decoder = new TextDecoder('utf8');\n  return 'u' + decoder.decode(buf);\n}, str => {\n  const encoder = new TextEncoder();\n  return encoder.encode(str.substring(1));\n});\nconst ascii = createCodec('ascii', 'a', buf => {\n  let string = 'a';\n\n  for (let i = 0; i < buf.length; i++) {\n    string += String.fromCharCode(buf[i]);\n  }\n\n  return string;\n}, str => {\n  str = str.substring(1);\n  const buf = new Uint8Array(str.length);\n\n  for (let i = 0; i < str.length; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n\n  return buf;\n});\n/**\n * @typedef {'utf8' | 'utf-8' | 'hex' | 'latin1' | 'ascii' | 'binary' | keyof bases } SupportedEncodings\n */\n\n/**\n * @type {Record<SupportedEncodings, MultibaseCodec>}\n */\n\nconst BASES = {\n  'utf8': string,\n  'utf-8': string,\n  'hex': bases.base16,\n  'latin1': ascii,\n  'ascii': ascii,\n  'binary': ascii,\n  ...bases\n};\nmodule.exports = BASES;","map":null,"metadata":{},"sourceType":"script"}